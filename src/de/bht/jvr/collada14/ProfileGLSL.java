//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB)
// Reference Implementation, vJAXB 2.1.10 in JDK 6
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source
// schema.
// Generated on: 2010.03.05 at 12:27:35 PM MEZ
//

package de.bht.jvr.collada14;

import java.util.ArrayList;
import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElements;
import javax.xml.bind.annotation.XmlID;
import javax.xml.bind.annotation.XmlList;
import javax.xml.bind.annotation.XmlSchemaType;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.XmlValue;
import javax.xml.bind.annotation.adapters.CollapsedStringAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;

/**
 * <p>
 * Java class for anonymous complex type.
 * <p>
 * The following schema fragment specifies the expected content contained within
 * this class.
 * 
 * <pre>
 * &lt;complexType>
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;sequence>
 *         &lt;element ref="{http://www.collada.org/2005/11/COLLADASchema}asset" minOccurs="0"/>
 *         &lt;choice maxOccurs="unbounded" minOccurs="0">
 *           &lt;element name="code" type="{http://www.collada.org/2005/11/COLLADASchema}fx_code_profile"/>
 *           &lt;element name="include" type="{http://www.collada.org/2005/11/COLLADASchema}fx_include_common"/>
 *         &lt;/choice>
 *         &lt;choice maxOccurs="unbounded" minOccurs="0">
 *           &lt;element ref="{http://www.collada.org/2005/11/COLLADASchema}image"/>
 *           &lt;element name="newparam" type="{http://www.collada.org/2005/11/COLLADASchema}glsl_newparam"/>
 *         &lt;/choice>
 *         &lt;element name="technique" maxOccurs="unbounded">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;sequence>
 *                   &lt;element name="annotate" type="{http://www.collada.org/2005/11/COLLADASchema}fx_annotate_common" maxOccurs="unbounded" minOccurs="0"/>
 *                   &lt;choice maxOccurs="unbounded" minOccurs="0">
 *                     &lt;element name="code" type="{http://www.collada.org/2005/11/COLLADASchema}fx_code_profile"/>
 *                     &lt;element name="include" type="{http://www.collada.org/2005/11/COLLADASchema}fx_include_common"/>
 *                   &lt;/choice>
 *                   &lt;choice maxOccurs="unbounded" minOccurs="0">
 *                     &lt;element ref="{http://www.collada.org/2005/11/COLLADASchema}image"/>
 *                     &lt;element name="newparam" type="{http://www.collada.org/2005/11/COLLADASchema}glsl_newparam"/>
 *                     &lt;element name="setparam" type="{http://www.collada.org/2005/11/COLLADASchema}glsl_setparam"/>
 *                   &lt;/choice>
 *                   &lt;element name="pass" maxOccurs="unbounded">
 *                     &lt;complexType>
 *                       &lt;complexContent>
 *                         &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                           &lt;sequence>
 *                             &lt;element name="annotate" type="{http://www.collada.org/2005/11/COLLADASchema}fx_annotate_common" maxOccurs="unbounded" minOccurs="0"/>
 *                             &lt;element name="color_target" type="{http://www.collada.org/2005/11/COLLADASchema}fx_colortarget_common" maxOccurs="unbounded" minOccurs="0"/>
 *                             &lt;element name="depth_target" type="{http://www.collada.org/2005/11/COLLADASchema}fx_depthtarget_common" maxOccurs="unbounded" minOccurs="0"/>
 *                             &lt;element name="stencil_target" type="{http://www.collada.org/2005/11/COLLADASchema}fx_stenciltarget_common" maxOccurs="unbounded" minOccurs="0"/>
 *                             &lt;element name="color_clear" type="{http://www.collada.org/2005/11/COLLADASchema}fx_clearcolor_common" maxOccurs="unbounded" minOccurs="0"/>
 *                             &lt;element name="depth_clear" type="{http://www.collada.org/2005/11/COLLADASchema}fx_cleardepth_common" maxOccurs="unbounded" minOccurs="0"/>
 *                             &lt;element name="stencil_clear" type="{http://www.collada.org/2005/11/COLLADASchema}fx_clearstencil_common" maxOccurs="unbounded" minOccurs="0"/>
 *                             &lt;element name="draw" type="{http://www.collada.org/2005/11/COLLADASchema}fx_draw_common" minOccurs="0"/>
 *                             &lt;choice maxOccurs="unbounded">
 *                               &lt;group ref="{http://www.collada.org/2005/11/COLLADASchema}gl_pipeline_settings"/>
 *                               &lt;element name="shader">
 *                                 &lt;complexType>
 *                                   &lt;complexContent>
 *                                     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                                       &lt;sequence>
 *                                         &lt;element name="annotate" type="{http://www.collada.org/2005/11/COLLADASchema}fx_annotate_common" maxOccurs="unbounded" minOccurs="0"/>
 *                                         &lt;sequence minOccurs="0">
 *                                           &lt;element name="compiler_target">
 *                                             &lt;complexType>
 *                                               &lt;simpleContent>
 *                                                 &lt;extension base="&lt;http://www.w3.org/2001/XMLSchema>NMTOKEN">
 *                                                 &lt;/extension>
 *                                               &lt;/simpleContent>
 *                                             &lt;/complexType>
 *                                           &lt;/element>
 *                                           &lt;element name="compiler_options" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/>
 *                                         &lt;/sequence>
 *                                         &lt;element name="name">
 *                                           &lt;complexType>
 *                                             &lt;simpleContent>
 *                                               &lt;extension base="&lt;http://www.w3.org/2001/XMLSchema>NCName">
 *                                                 &lt;attribute name="source" type="{http://www.w3.org/2001/XMLSchema}NCName" />
 *                                               &lt;/extension>
 *                                             &lt;/simpleContent>
 *                                           &lt;/complexType>
 *                                         &lt;/element>
 *                                         &lt;element name="bind" maxOccurs="unbounded" minOccurs="0">
 *                                           &lt;complexType>
 *                                             &lt;complexContent>
 *                                               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                                                 &lt;choice>
 *                                                   &lt;group ref="{http://www.collada.org/2005/11/COLLADASchema}glsl_param_type"/>
 *                                                   &lt;element name="param">
 *                                                     &lt;complexType>
 *                                                       &lt;complexContent>
 *                                                         &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                                                           &lt;attribute name="ref" use="required" type="{http://www.w3.org/2001/XMLSchema}string" />
 *                                                         &lt;/restriction>
 *                                                       &lt;/complexContent>
 *                                                     &lt;/complexType>
 *                                                   &lt;/element>
 *                                                 &lt;/choice>
 *                                                 &lt;attribute name="symbol" use="required" type="{http://www.w3.org/2001/XMLSchema}NCName" />
 *                                               &lt;/restriction>
 *                                             &lt;/complexContent>
 *                                           &lt;/complexType>
 *                                         &lt;/element>
 *                                       &lt;/sequence>
 *                                       &lt;attribute name="stage" type="{http://www.collada.org/2005/11/COLLADASchema}glsl_pipeline_stage" />
 *                                     &lt;/restriction>
 *                                   &lt;/complexContent>
 *                                 &lt;/complexType>
 *                               &lt;/element>
 *                             &lt;/choice>
 *                             &lt;element ref="{http://www.collada.org/2005/11/COLLADASchema}extra" maxOccurs="unbounded" minOccurs="0"/>
 *                           &lt;/sequence>
 *                           &lt;attribute name="sid" type="{http://www.w3.org/2001/XMLSchema}NCName" />
 *                         &lt;/restriction>
 *                       &lt;/complexContent>
 *                     &lt;/complexType>
 *                   &lt;/element>
 *                   &lt;element ref="{http://www.collada.org/2005/11/COLLADASchema}extra" maxOccurs="unbounded" minOccurs="0"/>
 *                 &lt;/sequence>
 *                 &lt;attribute name="id" type="{http://www.w3.org/2001/XMLSchema}ID" />
 *                 &lt;attribute name="sid" use="required" type="{http://www.w3.org/2001/XMLSchema}NCName" />
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element ref="{http://www.collada.org/2005/11/COLLADASchema}extra" maxOccurs="unbounded" minOccurs="0"/>
 *       &lt;/sequence>
 *       &lt;attribute name="id" type="{http://www.w3.org/2001/XMLSchema}ID" />
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "", propOrder = { "asset", "codesAndIncludes", "imagesAndNewparams", "techniques",
        "extras" })
public class ProfileGLSL {

    /**
     * <p>
     * Java class for anonymous complex type.
     * <p>
     * The following schema fragment specifies the expected content contained
     * within this class.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;sequence>
     *         &lt;element name="annotate" type="{http://www.collada.org/2005/11/COLLADASchema}fx_annotate_common" maxOccurs="unbounded" minOccurs="0"/>
     *         &lt;choice maxOccurs="unbounded" minOccurs="0">
     *           &lt;element name="code" type="{http://www.collada.org/2005/11/COLLADASchema}fx_code_profile"/>
     *           &lt;element name="include" type="{http://www.collada.org/2005/11/COLLADASchema}fx_include_common"/>
     *         &lt;/choice>
     *         &lt;choice maxOccurs="unbounded" minOccurs="0">
     *           &lt;element ref="{http://www.collada.org/2005/11/COLLADASchema}image"/>
     *           &lt;element name="newparam" type="{http://www.collada.org/2005/11/COLLADASchema}glsl_newparam"/>
     *           &lt;element name="setparam" type="{http://www.collada.org/2005/11/COLLADASchema}glsl_setparam"/>
     *         &lt;/choice>
     *         &lt;element name="pass" maxOccurs="unbounded">
     *           &lt;complexType>
     *             &lt;complexContent>
     *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *                 &lt;sequence>
     *                   &lt;element name="annotate" type="{http://www.collada.org/2005/11/COLLADASchema}fx_annotate_common" maxOccurs="unbounded" minOccurs="0"/>
     *                   &lt;element name="color_target" type="{http://www.collada.org/2005/11/COLLADASchema}fx_colortarget_common" maxOccurs="unbounded" minOccurs="0"/>
     *                   &lt;element name="depth_target" type="{http://www.collada.org/2005/11/COLLADASchema}fx_depthtarget_common" maxOccurs="unbounded" minOccurs="0"/>
     *                   &lt;element name="stencil_target" type="{http://www.collada.org/2005/11/COLLADASchema}fx_stenciltarget_common" maxOccurs="unbounded" minOccurs="0"/>
     *                   &lt;element name="color_clear" type="{http://www.collada.org/2005/11/COLLADASchema}fx_clearcolor_common" maxOccurs="unbounded" minOccurs="0"/>
     *                   &lt;element name="depth_clear" type="{http://www.collada.org/2005/11/COLLADASchema}fx_cleardepth_common" maxOccurs="unbounded" minOccurs="0"/>
     *                   &lt;element name="stencil_clear" type="{http://www.collada.org/2005/11/COLLADASchema}fx_clearstencil_common" maxOccurs="unbounded" minOccurs="0"/>
     *                   &lt;element name="draw" type="{http://www.collada.org/2005/11/COLLADASchema}fx_draw_common" minOccurs="0"/>
     *                   &lt;choice maxOccurs="unbounded">
     *                     &lt;group ref="{http://www.collada.org/2005/11/COLLADASchema}gl_pipeline_settings"/>
     *                     &lt;element name="shader">
     *                       &lt;complexType>
     *                         &lt;complexContent>
     *                           &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *                             &lt;sequence>
     *                               &lt;element name="annotate" type="{http://www.collada.org/2005/11/COLLADASchema}fx_annotate_common" maxOccurs="unbounded" minOccurs="0"/>
     *                               &lt;sequence minOccurs="0">
     *                                 &lt;element name="compiler_target">
     *                                   &lt;complexType>
     *                                     &lt;simpleContent>
     *                                       &lt;extension base="&lt;http://www.w3.org/2001/XMLSchema>NMTOKEN">
     *                                       &lt;/extension>
     *                                     &lt;/simpleContent>
     *                                   &lt;/complexType>
     *                                 &lt;/element>
     *                                 &lt;element name="compiler_options" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/>
     *                               &lt;/sequence>
     *                               &lt;element name="name">
     *                                 &lt;complexType>
     *                                   &lt;simpleContent>
     *                                     &lt;extension base="&lt;http://www.w3.org/2001/XMLSchema>NCName">
     *                                       &lt;attribute name="source" type="{http://www.w3.org/2001/XMLSchema}NCName" />
     *                                     &lt;/extension>
     *                                   &lt;/simpleContent>
     *                                 &lt;/complexType>
     *                               &lt;/element>
     *                               &lt;element name="bind" maxOccurs="unbounded" minOccurs="0">
     *                                 &lt;complexType>
     *                                   &lt;complexContent>
     *                                     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *                                       &lt;choice>
     *                                         &lt;group ref="{http://www.collada.org/2005/11/COLLADASchema}glsl_param_type"/>
     *                                         &lt;element name="param">
     *                                           &lt;complexType>
     *                                             &lt;complexContent>
     *                                               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *                                                 &lt;attribute name="ref" use="required" type="{http://www.w3.org/2001/XMLSchema}string" />
     *                                               &lt;/restriction>
     *                                             &lt;/complexContent>
     *                                           &lt;/complexType>
     *                                         &lt;/element>
     *                                       &lt;/choice>
     *                                       &lt;attribute name="symbol" use="required" type="{http://www.w3.org/2001/XMLSchema}NCName" />
     *                                     &lt;/restriction>
     *                                   &lt;/complexContent>
     *                                 &lt;/complexType>
     *                               &lt;/element>
     *                             &lt;/sequence>
     *                             &lt;attribute name="stage" type="{http://www.collada.org/2005/11/COLLADASchema}glsl_pipeline_stage" />
     *                           &lt;/restriction>
     *                         &lt;/complexContent>
     *                       &lt;/complexType>
     *                     &lt;/element>
     *                   &lt;/choice>
     *                   &lt;element ref="{http://www.collada.org/2005/11/COLLADASchema}extra" maxOccurs="unbounded" minOccurs="0"/>
     *                 &lt;/sequence>
     *                 &lt;attribute name="sid" type="{http://www.w3.org/2001/XMLSchema}NCName" />
     *               &lt;/restriction>
     *             &lt;/complexContent>
     *           &lt;/complexType>
     *         &lt;/element>
     *         &lt;element ref="{http://www.collada.org/2005/11/COLLADASchema}extra" maxOccurs="unbounded" minOccurs="0"/>
     *       &lt;/sequence>
     *       &lt;attribute name="id" type="{http://www.w3.org/2001/XMLSchema}ID" />
     *       &lt;attribute name="sid" use="required" type="{http://www.w3.org/2001/XMLSchema}NCName" />
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = { "annotates", "codesAndIncludes",
            "imagesAndNewparamsAndSetparams", "passes", "extras" })
    public static class Technique {

        /**
         * <p>
         * Java class for anonymous complex type.
         * <p>
         * The following schema fragment specifies the expected content
         * contained within this class.
         * 
         * <pre>
         * &lt;complexType>
         *   &lt;complexContent>
         *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
         *       &lt;sequence>
         *         &lt;element name="annotate" type="{http://www.collada.org/2005/11/COLLADASchema}fx_annotate_common" maxOccurs="unbounded" minOccurs="0"/>
         *         &lt;element name="color_target" type="{http://www.collada.org/2005/11/COLLADASchema}fx_colortarget_common" maxOccurs="unbounded" minOccurs="0"/>
         *         &lt;element name="depth_target" type="{http://www.collada.org/2005/11/COLLADASchema}fx_depthtarget_common" maxOccurs="unbounded" minOccurs="0"/>
         *         &lt;element name="stencil_target" type="{http://www.collada.org/2005/11/COLLADASchema}fx_stenciltarget_common" maxOccurs="unbounded" minOccurs="0"/>
         *         &lt;element name="color_clear" type="{http://www.collada.org/2005/11/COLLADASchema}fx_clearcolor_common" maxOccurs="unbounded" minOccurs="0"/>
         *         &lt;element name="depth_clear" type="{http://www.collada.org/2005/11/COLLADASchema}fx_cleardepth_common" maxOccurs="unbounded" minOccurs="0"/>
         *         &lt;element name="stencil_clear" type="{http://www.collada.org/2005/11/COLLADASchema}fx_clearstencil_common" maxOccurs="unbounded" minOccurs="0"/>
         *         &lt;element name="draw" type="{http://www.collada.org/2005/11/COLLADASchema}fx_draw_common" minOccurs="0"/>
         *         &lt;choice maxOccurs="unbounded">
         *           &lt;group ref="{http://www.collada.org/2005/11/COLLADASchema}gl_pipeline_settings"/>
         *           &lt;element name="shader">
         *             &lt;complexType>
         *               &lt;complexContent>
         *                 &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
         *                   &lt;sequence>
         *                     &lt;element name="annotate" type="{http://www.collada.org/2005/11/COLLADASchema}fx_annotate_common" maxOccurs="unbounded" minOccurs="0"/>
         *                     &lt;sequence minOccurs="0">
         *                       &lt;element name="compiler_target">
         *                         &lt;complexType>
         *                           &lt;simpleContent>
         *                             &lt;extension base="&lt;http://www.w3.org/2001/XMLSchema>NMTOKEN">
         *                             &lt;/extension>
         *                           &lt;/simpleContent>
         *                         &lt;/complexType>
         *                       &lt;/element>
         *                       &lt;element name="compiler_options" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/>
         *                     &lt;/sequence>
         *                     &lt;element name="name">
         *                       &lt;complexType>
         *                         &lt;simpleContent>
         *                           &lt;extension base="&lt;http://www.w3.org/2001/XMLSchema>NCName">
         *                             &lt;attribute name="source" type="{http://www.w3.org/2001/XMLSchema}NCName" />
         *                           &lt;/extension>
         *                         &lt;/simpleContent>
         *                       &lt;/complexType>
         *                     &lt;/element>
         *                     &lt;element name="bind" maxOccurs="unbounded" minOccurs="0">
         *                       &lt;complexType>
         *                         &lt;complexContent>
         *                           &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
         *                             &lt;choice>
         *                               &lt;group ref="{http://www.collada.org/2005/11/COLLADASchema}glsl_param_type"/>
         *                               &lt;element name="param">
         *                                 &lt;complexType>
         *                                   &lt;complexContent>
         *                                     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
         *                                       &lt;attribute name="ref" use="required" type="{http://www.w3.org/2001/XMLSchema}string" />
         *                                     &lt;/restriction>
         *                                   &lt;/complexContent>
         *                                 &lt;/complexType>
         *                               &lt;/element>
         *                             &lt;/choice>
         *                             &lt;attribute name="symbol" use="required" type="{http://www.w3.org/2001/XMLSchema}NCName" />
         *                           &lt;/restriction>
         *                         &lt;/complexContent>
         *                       &lt;/complexType>
         *                     &lt;/element>
         *                   &lt;/sequence>
         *                   &lt;attribute name="stage" type="{http://www.collada.org/2005/11/COLLADASchema}glsl_pipeline_stage" />
         *                 &lt;/restriction>
         *               &lt;/complexContent>
         *             &lt;/complexType>
         *           &lt;/element>
         *         &lt;/choice>
         *         &lt;element ref="{http://www.collada.org/2005/11/COLLADASchema}extra" maxOccurs="unbounded" minOccurs="0"/>
         *       &lt;/sequence>
         *       &lt;attribute name="sid" type="{http://www.w3.org/2001/XMLSchema}NCName" />
         *     &lt;/restriction>
         *   &lt;/complexContent>
         * &lt;/complexType>
         * </pre>
         */
        @XmlAccessorType(XmlAccessType.FIELD)
        @XmlType(name = "", propOrder = { "annotates", "colorTargets", "depthTargets",
                "stencilTargets", "colorClears", "depthClears", "stencilClears", "draw",
                "alphaFuncsAndBlendFuncsAndBlendFuncSeparates", "extras" })
        public static class Pass {

            /**
             * <p>
             * Java class for anonymous complex type.
             * <p>
             * The following schema fragment specifies the expected content
             * contained within this class.
             * 
             * <pre>
             * &lt;complexType>
             *   &lt;complexContent>
             *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
             *       &lt;sequence>
             *         &lt;element name="annotate" type="{http://www.collada.org/2005/11/COLLADASchema}fx_annotate_common" maxOccurs="unbounded" minOccurs="0"/>
             *         &lt;sequence minOccurs="0">
             *           &lt;element name="compiler_target">
             *             &lt;complexType>
             *               &lt;simpleContent>
             *                 &lt;extension base="&lt;http://www.w3.org/2001/XMLSchema>NMTOKEN">
             *                 &lt;/extension>
             *               &lt;/simpleContent>
             *             &lt;/complexType>
             *           &lt;/element>
             *           &lt;element name="compiler_options" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/>
             *         &lt;/sequence>
             *         &lt;element name="name">
             *           &lt;complexType>
             *             &lt;simpleContent>
             *               &lt;extension base="&lt;http://www.w3.org/2001/XMLSchema>NCName">
             *                 &lt;attribute name="source" type="{http://www.w3.org/2001/XMLSchema}NCName" />
             *               &lt;/extension>
             *             &lt;/simpleContent>
             *           &lt;/complexType>
             *         &lt;/element>
             *         &lt;element name="bind" maxOccurs="unbounded" minOccurs="0">
             *           &lt;complexType>
             *             &lt;complexContent>
             *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
             *                 &lt;choice>
             *                   &lt;group ref="{http://www.collada.org/2005/11/COLLADASchema}glsl_param_type"/>
             *                   &lt;element name="param">
             *                     &lt;complexType>
             *                       &lt;complexContent>
             *                         &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
             *                           &lt;attribute name="ref" use="required" type="{http://www.w3.org/2001/XMLSchema}string" />
             *                         &lt;/restriction>
             *                       &lt;/complexContent>
             *                     &lt;/complexType>
             *                   &lt;/element>
             *                 &lt;/choice>
             *                 &lt;attribute name="symbol" use="required" type="{http://www.w3.org/2001/XMLSchema}NCName" />
             *               &lt;/restriction>
             *             &lt;/complexContent>
             *           &lt;/complexType>
             *         &lt;/element>
             *       &lt;/sequence>
             *       &lt;attribute name="stage" type="{http://www.collada.org/2005/11/COLLADASchema}glsl_pipeline_stage" />
             *     &lt;/restriction>
             *   &lt;/complexContent>
             * &lt;/complexType>
             * </pre>
             */
            @XmlAccessorType(XmlAccessType.FIELD)
            @XmlType(name = "", propOrder = { "annotates", "compilerTarget", "compilerOptions",
                    "name", "binds" })
            public static class Shader {

                /**
                 * <p>
                 * Java class for anonymous complex type.
                 * <p>
                 * The following schema fragment specifies the expected content
                 * contained within this class.
                 * 
                 * <pre>
                 * &lt;complexType>
                 *   &lt;complexContent>
                 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
                 *       &lt;choice>
                 *         &lt;group ref="{http://www.collada.org/2005/11/COLLADASchema}glsl_param_type"/>
                 *         &lt;element name="param">
                 *           &lt;complexType>
                 *             &lt;complexContent>
                 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
                 *                 &lt;attribute name="ref" use="required" type="{http://www.w3.org/2001/XMLSchema}string" />
                 *               &lt;/restriction>
                 *             &lt;/complexContent>
                 *           &lt;/complexType>
                 *         &lt;/element>
                 *       &lt;/choice>
                 *       &lt;attribute name="symbol" use="required" type="{http://www.w3.org/2001/XMLSchema}NCName" />
                 *     &lt;/restriction>
                 *   &lt;/complexContent>
                 * &lt;/complexType>
                 * </pre>
                 */
                @XmlAccessorType(XmlAccessType.FIELD)
                @XmlType(name = "", propOrder = { "param", "_enum", "samplerDEPTH", "samplerRECT",
                        "samplerCUBE", "sampler3D", "sampler2D", "sampler1D", "surface", "int4",
                        "int3", "int2", "_int", "float4X4", "float3X3", "float2X2", "float4",
                        "float3", "float2", "_float", "bool4", "bool3", "bool2", "bool" })
                public static class Bind {

                    /**
                     * <p>
                     * Java class for anonymous complex type.
                     * <p>
                     * The following schema fragment specifies the expected
                     * content contained within this class.
                     * 
                     * <pre>
                     * &lt;complexType>
                     *   &lt;complexContent>
                     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
                     *       &lt;attribute name="ref" use="required" type="{http://www.w3.org/2001/XMLSchema}string" />
                     *     &lt;/restriction>
                     *   &lt;/complexContent>
                     * &lt;/complexType>
                     * </pre>
                     */
                    @XmlAccessorType(XmlAccessType.FIELD)
                    @XmlType(name = "")
                    public static class Param {

                        @XmlAttribute(required = true)
                        protected String ref;

                        /**
                         * Gets the value of the ref property.
                         * 
                         * @return possible object is {@link String }
                         */
                        public String getRef() {
                            return ref;
                        }

                        /**
                         * Sets the value of the ref property.
                         * 
                         * @param value
                         *            allowed object is {@link String }
                         */
                        public void setRef(String value) {
                            ref = value;
                        }

                    }

                    protected ProfileGLSL.Technique.Pass.Shader.Bind.Param param;
                    @XmlElement(name = "enum")
                    protected String _enum;
                    protected GlSamplerDEPTH samplerDEPTH;
                    protected GlSamplerRECT samplerRECT;
                    protected GlSamplerCUBE samplerCUBE;
                    protected GlSampler3D sampler3D;
                    protected GlSampler2D sampler2D;
                    protected GlSampler1D sampler1D;
                    protected GlslSurfaceType surface;
                    @XmlList
                    @XmlElement(type = Integer.class)
                    protected List<Integer> int4;
                    @XmlList
                    @XmlElement(type = Integer.class)
                    protected List<Integer> int3;
                    @XmlList
                    @XmlElement(type = Integer.class)
                    protected List<Integer> int2;
                    @XmlElement(name = "int")
                    protected Integer _int;
                    @XmlList
                    @XmlElement(name = "float4x4", type = Float.class)
                    protected List<Float> float4X4;
                    @XmlList
                    @XmlElement(name = "float3x3", type = Float.class)
                    protected List<Float> float3X3;
                    @XmlList
                    @XmlElement(name = "float2x2", type = Float.class)
                    protected List<Float> float2X2;
                    @XmlList
                    @XmlElement(type = Float.class)
                    protected List<Float> float4;
                    @XmlList
                    @XmlElement(type = Float.class)
                    protected List<Float> float3;
                    @XmlList
                    @XmlElement(type = Float.class)
                    protected List<Float> float2;
                    @XmlElement(name = "float")
                    protected Float _float;
                    @XmlList
                    @XmlElement(type = Boolean.class)
                    protected List<Boolean> bool4;
                    @XmlList
                    @XmlElement(type = Boolean.class)
                    protected List<Boolean> bool3;
                    @XmlList
                    @XmlElement(type = Boolean.class)
                    protected List<Boolean> bool2;
                    protected Boolean bool;

                    @XmlAttribute(required = true)
                    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
                    @XmlSchemaType(name = "NCName")
                    protected String symbol;

                    /**
                     * Gets the value of the bool2 property.
                     * <p>
                     * This accessor method returns a reference to the live
                     * list, not a snapshot. Therefore any modification you make
                     * to the returned list will be present inside the JAXB
                     * object. This is why there is not a <CODE>set</CODE>
                     * method for the bool2 property.
                     * <p>
                     * For example, to add a new item, do as follows:
                     * 
                     * <pre>
                     * getBool2().add(newItem);
                     * </pre>
                     * <p>
                     * Objects of the following type(s) are allowed in the list
                     * {@link Boolean }
                     */
                    public List<Boolean> getBool2() {
                        if (bool2 == null)
                            bool2 = new ArrayList<Boolean>();
                        return bool2;
                    }

                    /**
                     * Gets the value of the bool3 property.
                     * <p>
                     * This accessor method returns a reference to the live
                     * list, not a snapshot. Therefore any modification you make
                     * to the returned list will be present inside the JAXB
                     * object. This is why there is not a <CODE>set</CODE>
                     * method for the bool3 property.
                     * <p>
                     * For example, to add a new item, do as follows:
                     * 
                     * <pre>
                     * getBool3().add(newItem);
                     * </pre>
                     * <p>
                     * Objects of the following type(s) are allowed in the list
                     * {@link Boolean }
                     */
                    public List<Boolean> getBool3() {
                        if (bool3 == null)
                            bool3 = new ArrayList<Boolean>();
                        return bool3;
                    }

                    /**
                     * Gets the value of the bool4 property.
                     * <p>
                     * This accessor method returns a reference to the live
                     * list, not a snapshot. Therefore any modification you make
                     * to the returned list will be present inside the JAXB
                     * object. This is why there is not a <CODE>set</CODE>
                     * method for the bool4 property.
                     * <p>
                     * For example, to add a new item, do as follows:
                     * 
                     * <pre>
                     * getBool4().add(newItem);
                     * </pre>
                     * <p>
                     * Objects of the following type(s) are allowed in the list
                     * {@link Boolean }
                     */
                    public List<Boolean> getBool4() {
                        if (bool4 == null)
                            bool4 = new ArrayList<Boolean>();
                        return bool4;
                    }

                    /**
                     * Gets the value of the enum property.
                     * 
                     * @return possible object is {@link String }
                     */
                    public String getEnum() {
                        return _enum;
                    }

                    /**
                     * Gets the value of the float property.
                     * 
                     * @return possible object is {@link Float }
                     */
                    public Float getFloat() {
                        return _float;
                    }

                    /**
                     * Gets the value of the float2 property.
                     * <p>
                     * This accessor method returns a reference to the live
                     * list, not a snapshot. Therefore any modification you make
                     * to the returned list will be present inside the JAXB
                     * object. This is why there is not a <CODE>set</CODE>
                     * method for the float2 property.
                     * <p>
                     * For example, to add a new item, do as follows:
                     * 
                     * <pre>
                     * getFloat2().add(newItem);
                     * </pre>
                     * <p>
                     * Objects of the following type(s) are allowed in the list
                     * {@link Float }
                     */
                    public List<Float> getFloat2() {
                        if (float2 == null)
                            float2 = new ArrayList<Float>();
                        return float2;
                    }

                    /**
                     * Gets the value of the float2X2 property.
                     * <p>
                     * This accessor method returns a reference to the live
                     * list, not a snapshot. Therefore any modification you make
                     * to the returned list will be present inside the JAXB
                     * object. This is why there is not a <CODE>set</CODE>
                     * method for the float2X2 property.
                     * <p>
                     * For example, to add a new item, do as follows:
                     * 
                     * <pre>
                     * getFloat2X2().add(newItem);
                     * </pre>
                     * <p>
                     * Objects of the following type(s) are allowed in the list
                     * {@link Float }
                     */
                    public List<Float> getFloat2X2() {
                        if (float2X2 == null)
                            float2X2 = new ArrayList<Float>();
                        return float2X2;
                    }

                    /**
                     * Gets the value of the float3 property.
                     * <p>
                     * This accessor method returns a reference to the live
                     * list, not a snapshot. Therefore any modification you make
                     * to the returned list will be present inside the JAXB
                     * object. This is why there is not a <CODE>set</CODE>
                     * method for the float3 property.
                     * <p>
                     * For example, to add a new item, do as follows:
                     * 
                     * <pre>
                     * getFloat3().add(newItem);
                     * </pre>
                     * <p>
                     * Objects of the following type(s) are allowed in the list
                     * {@link Float }
                     */
                    public List<Float> getFloat3() {
                        if (float3 == null)
                            float3 = new ArrayList<Float>();
                        return float3;
                    }

                    /**
                     * Gets the value of the float3X3 property.
                     * <p>
                     * This accessor method returns a reference to the live
                     * list, not a snapshot. Therefore any modification you make
                     * to the returned list will be present inside the JAXB
                     * object. This is why there is not a <CODE>set</CODE>
                     * method for the float3X3 property.
                     * <p>
                     * For example, to add a new item, do as follows:
                     * 
                     * <pre>
                     * getFloat3X3().add(newItem);
                     * </pre>
                     * <p>
                     * Objects of the following type(s) are allowed in the list
                     * {@link Float }
                     */
                    public List<Float> getFloat3X3() {
                        if (float3X3 == null)
                            float3X3 = new ArrayList<Float>();
                        return float3X3;
                    }

                    /**
                     * Gets the value of the float4 property.
                     * <p>
                     * This accessor method returns a reference to the live
                     * list, not a snapshot. Therefore any modification you make
                     * to the returned list will be present inside the JAXB
                     * object. This is why there is not a <CODE>set</CODE>
                     * method for the float4 property.
                     * <p>
                     * For example, to add a new item, do as follows:
                     * 
                     * <pre>
                     * getFloat4().add(newItem);
                     * </pre>
                     * <p>
                     * Objects of the following type(s) are allowed in the list
                     * {@link Float }
                     */
                    public List<Float> getFloat4() {
                        if (float4 == null)
                            float4 = new ArrayList<Float>();
                        return float4;
                    }

                    /**
                     * Gets the value of the float4X4 property.
                     * <p>
                     * This accessor method returns a reference to the live
                     * list, not a snapshot. Therefore any modification you make
                     * to the returned list will be present inside the JAXB
                     * object. This is why there is not a <CODE>set</CODE>
                     * method for the float4X4 property.
                     * <p>
                     * For example, to add a new item, do as follows:
                     * 
                     * <pre>
                     * getFloat4X4().add(newItem);
                     * </pre>
                     * <p>
                     * Objects of the following type(s) are allowed in the list
                     * {@link Float }
                     */
                    public List<Float> getFloat4X4() {
                        if (float4X4 == null)
                            float4X4 = new ArrayList<Float>();
                        return float4X4;
                    }

                    /**
                     * Gets the value of the int property.
                     * 
                     * @return possible object is {@link Integer }
                     */
                    public Integer getInt() {
                        return _int;
                    }

                    /**
                     * Gets the value of the int2 property.
                     * <p>
                     * This accessor method returns a reference to the live
                     * list, not a snapshot. Therefore any modification you make
                     * to the returned list will be present inside the JAXB
                     * object. This is why there is not a <CODE>set</CODE>
                     * method for the int2 property.
                     * <p>
                     * For example, to add a new item, do as follows:
                     * 
                     * <pre>
                     * getInt2().add(newItem);
                     * </pre>
                     * <p>
                     * Objects of the following type(s) are allowed in the list
                     * {@link Integer }
                     */
                    public List<Integer> getInt2() {
                        if (int2 == null)
                            int2 = new ArrayList<Integer>();
                        return int2;
                    }

                    /**
                     * Gets the value of the int3 property.
                     * <p>
                     * This accessor method returns a reference to the live
                     * list, not a snapshot. Therefore any modification you make
                     * to the returned list will be present inside the JAXB
                     * object. This is why there is not a <CODE>set</CODE>
                     * method for the int3 property.
                     * <p>
                     * For example, to add a new item, do as follows:
                     * 
                     * <pre>
                     * getInt3().add(newItem);
                     * </pre>
                     * <p>
                     * Objects of the following type(s) are allowed in the list
                     * {@link Integer }
                     */
                    public List<Integer> getInt3() {
                        if (int3 == null)
                            int3 = new ArrayList<Integer>();
                        return int3;
                    }

                    /**
                     * Gets the value of the int4 property.
                     * <p>
                     * This accessor method returns a reference to the live
                     * list, not a snapshot. Therefore any modification you make
                     * to the returned list will be present inside the JAXB
                     * object. This is why there is not a <CODE>set</CODE>
                     * method for the int4 property.
                     * <p>
                     * For example, to add a new item, do as follows:
                     * 
                     * <pre>
                     * getInt4().add(newItem);
                     * </pre>
                     * <p>
                     * Objects of the following type(s) are allowed in the list
                     * {@link Integer }
                     */
                    public List<Integer> getInt4() {
                        if (int4 == null)
                            int4 = new ArrayList<Integer>();
                        return int4;
                    }

                    /**
                     * Gets the value of the param property.
                     * 
                     * @return possible object is
                     *         {@link ProfileGLSL.Technique.Pass.Shader.Bind.Param }
                     */
                    public ProfileGLSL.Technique.Pass.Shader.Bind.Param getParam() {
                        return param;
                    }

                    /**
                     * Gets the value of the sampler1D property.
                     * 
                     * @return possible object is {@link GlSampler1D }
                     */
                    public GlSampler1D getSampler1D() {
                        return sampler1D;
                    }

                    /**
                     * Gets the value of the sampler2D property.
                     * 
                     * @return possible object is {@link GlSampler2D }
                     */
                    public GlSampler2D getSampler2D() {
                        return sampler2D;
                    }

                    /**
                     * Gets the value of the sampler3D property.
                     * 
                     * @return possible object is {@link GlSampler3D }
                     */
                    public GlSampler3D getSampler3D() {
                        return sampler3D;
                    }

                    /**
                     * Gets the value of the samplerCUBE property.
                     * 
                     * @return possible object is {@link GlSamplerCUBE }
                     */
                    public GlSamplerCUBE getSamplerCUBE() {
                        return samplerCUBE;
                    }

                    /**
                     * Gets the value of the samplerDEPTH property.
                     * 
                     * @return possible object is {@link GlSamplerDEPTH }
                     */
                    public GlSamplerDEPTH getSamplerDEPTH() {
                        return samplerDEPTH;
                    }

                    /**
                     * Gets the value of the samplerRECT property.
                     * 
                     * @return possible object is {@link GlSamplerRECT }
                     */
                    public GlSamplerRECT getSamplerRECT() {
                        return samplerRECT;
                    }

                    /**
                     * Gets the value of the surface property.
                     * 
                     * @return possible object is {@link GlslSurfaceType }
                     */
                    public GlslSurfaceType getSurface() {
                        return surface;
                    }

                    /**
                     * Gets the value of the symbol property.
                     * 
                     * @return possible object is {@link String }
                     */
                    public String getSymbol() {
                        return symbol;
                    }

                    /**
                     * Gets the value of the bool property.
                     * 
                     * @return possible object is {@link Boolean }
                     */
                    public Boolean isBool() {
                        return bool;
                    }

                    /**
                     * Sets the value of the bool property.
                     * 
                     * @param value
                     *            allowed object is {@link Boolean }
                     */
                    public void setBool(Boolean value) {
                        bool = value;
                    }

                    /**
                     * Sets the value of the enum property.
                     * 
                     * @param value
                     *            allowed object is {@link String }
                     */
                    public void setEnum(String value) {
                        _enum = value;
                    }

                    /**
                     * Sets the value of the float property.
                     * 
                     * @param value
                     *            allowed object is {@link Float }
                     */
                    public void setFloat(Float value) {
                        _float = value;
                    }

                    /**
                     * Sets the value of the int property.
                     * 
                     * @param value
                     *            allowed object is {@link Integer }
                     */
                    public void setInt(Integer value) {
                        _int = value;
                    }

                    /**
                     * Sets the value of the param property.
                     * 
                     * @param value
                     *            allowed object is
                     *            {@link ProfileGLSL.Technique.Pass.Shader.Bind.Param }
                     */
                    public void setParam(ProfileGLSL.Technique.Pass.Shader.Bind.Param value) {
                        param = value;
                    }

                    /**
                     * Sets the value of the sampler1D property.
                     * 
                     * @param value
                     *            allowed object is {@link GlSampler1D }
                     */
                    public void setSampler1D(GlSampler1D value) {
                        sampler1D = value;
                    }

                    /**
                     * Sets the value of the sampler2D property.
                     * 
                     * @param value
                     *            allowed object is {@link GlSampler2D }
                     */
                    public void setSampler2D(GlSampler2D value) {
                        sampler2D = value;
                    }

                    /**
                     * Sets the value of the sampler3D property.
                     * 
                     * @param value
                     *            allowed object is {@link GlSampler3D }
                     */
                    public void setSampler3D(GlSampler3D value) {
                        sampler3D = value;
                    }

                    /**
                     * Sets the value of the samplerCUBE property.
                     * 
                     * @param value
                     *            allowed object is {@link GlSamplerCUBE }
                     */
                    public void setSamplerCUBE(GlSamplerCUBE value) {
                        samplerCUBE = value;
                    }

                    /**
                     * Sets the value of the samplerDEPTH property.
                     * 
                     * @param value
                     *            allowed object is {@link GlSamplerDEPTH }
                     */
                    public void setSamplerDEPTH(GlSamplerDEPTH value) {
                        samplerDEPTH = value;
                    }

                    /**
                     * Sets the value of the samplerRECT property.
                     * 
                     * @param value
                     *            allowed object is {@link GlSamplerRECT }
                     */
                    public void setSamplerRECT(GlSamplerRECT value) {
                        samplerRECT = value;
                    }

                    /**
                     * Sets the value of the surface property.
                     * 
                     * @param value
                     *            allowed object is {@link GlslSurfaceType }
                     */
                    public void setSurface(GlslSurfaceType value) {
                        surface = value;
                    }

                    /**
                     * Sets the value of the symbol property.
                     * 
                     * @param value
                     *            allowed object is {@link String }
                     */
                    public void setSymbol(String value) {
                        symbol = value;
                    }

                }

                /**
                 * <p>
                 * Java class for anonymous complex type.
                 * <p>
                 * The following schema fragment specifies the expected content
                 * contained within this class.
                 * 
                 * <pre>
                 * &lt;complexType>
                 *   &lt;simpleContent>
                 *     &lt;extension base="&lt;http://www.w3.org/2001/XMLSchema>NMTOKEN">
                 *     &lt;/extension>
                 *   &lt;/simpleContent>
                 * &lt;/complexType>
                 * </pre>
                 */
                @XmlAccessorType(XmlAccessType.FIELD)
                @XmlType(name = "", propOrder = { "value" })
                public static class CompilerTarget {

                    @XmlValue
                    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
                    @XmlSchemaType(name = "NMTOKEN")
                    protected String value;

                    /**
                     * Gets the value of the value property.
                     * 
                     * @return possible object is {@link String }
                     */
                    public String getValue() {
                        return value;
                    }

                    /**
                     * Sets the value of the value property.
                     * 
                     * @param value
                     *            allowed object is {@link String }
                     */
                    public void setValue(String value) {
                        this.value = value;
                    }

                }

                /**
                 * <p>
                 * Java class for anonymous complex type.
                 * <p>
                 * The following schema fragment specifies the expected content
                 * contained within this class.
                 * 
                 * <pre>
                 * &lt;complexType>
                 *   &lt;simpleContent>
                 *     &lt;extension base="&lt;http://www.w3.org/2001/XMLSchema>NCName">
                 *       &lt;attribute name="source" type="{http://www.w3.org/2001/XMLSchema}NCName" />
                 *     &lt;/extension>
                 *   &lt;/simpleContent>
                 * &lt;/complexType>
                 * </pre>
                 */
                @XmlAccessorType(XmlAccessType.FIELD)
                @XmlType(name = "", propOrder = { "value" })
                public static class Name {

                    @XmlValue
                    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
                    @XmlSchemaType(name = "NCName")
                    protected String value;
                    @XmlAttribute
                    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
                    @XmlSchemaType(name = "NCName")
                    protected String source;

                    /**
                     * Gets the value of the source property.
                     * 
                     * @return possible object is {@link String }
                     */
                    public String getSource() {
                        return source;
                    }

                    /**
                     * Gets the value of the value property.
                     * 
                     * @return possible object is {@link String }
                     */
                    public String getValue() {
                        return value;
                    }

                    /**
                     * Sets the value of the source property.
                     * 
                     * @param value
                     *            allowed object is {@link String }
                     */
                    public void setSource(String value) {
                        source = value;
                    }

                    /**
                     * Sets the value of the value property.
                     * 
                     * @param value
                     *            allowed object is {@link String }
                     */
                    public void setValue(String value) {
                        this.value = value;
                    }

                }

                @XmlElement(name = "annotate")
                protected List<FxAnnotateCommon> annotates;
                @XmlElement(name = "compiler_target")
                protected ProfileGLSL.Technique.Pass.Shader.CompilerTarget compilerTarget;
                @XmlElement(name = "compiler_options")
                protected String compilerOptions;

                @XmlElement(required = true)
                protected ProfileGLSL.Technique.Pass.Shader.Name name;

                @XmlElement(name = "bind")
                protected List<ProfileGLSL.Technique.Pass.Shader.Bind> binds;

                @XmlAttribute
                protected GlslPipelineStage stage;

                /**
                 * Gets the value of the annotates property.
                 * <p>
                 * This accessor method returns a reference to the live list,
                 * not a snapshot. Therefore any modification you make to the
                 * returned list will be present inside the JAXB object. This is
                 * why there is not a <CODE>set</CODE> method for the annotates
                 * property.
                 * <p>
                 * For example, to add a new item, do as follows:
                 * 
                 * <pre>
                 * getAnnotates().add(newItem);
                 * </pre>
                 * <p>
                 * Objects of the following type(s) are allowed in the list
                 * {@link FxAnnotateCommon }
                 */
                public List<FxAnnotateCommon> getAnnotates() {
                    if (annotates == null)
                        annotates = new ArrayList<FxAnnotateCommon>();
                    return annotates;
                }

                /**
                 * Gets the value of the binds property.
                 * <p>
                 * This accessor method returns a reference to the live list,
                 * not a snapshot. Therefore any modification you make to the
                 * returned list will be present inside the JAXB object. This is
                 * why there is not a <CODE>set</CODE> method for the binds
                 * property.
                 * <p>
                 * For example, to add a new item, do as follows:
                 * 
                 * <pre>
                 * getBinds().add(newItem);
                 * </pre>
                 * <p>
                 * Objects of the following type(s) are allowed in the list
                 * {@link ProfileGLSL.Technique.Pass.Shader.Bind }
                 */
                public List<ProfileGLSL.Technique.Pass.Shader.Bind> getBinds() {
                    if (binds == null)
                        binds = new ArrayList<ProfileGLSL.Technique.Pass.Shader.Bind>();
                    return binds;
                }

                /**
                 * Gets the value of the compilerOptions property.
                 * 
                 * @return possible object is {@link String }
                 */
                public String getCompilerOptions() {
                    return compilerOptions;
                }

                /**
                 * Gets the value of the compilerTarget property.
                 * 
                 * @return possible object is
                 *         {@link ProfileGLSL.Technique.Pass.Shader.CompilerTarget }
                 */
                public ProfileGLSL.Technique.Pass.Shader.CompilerTarget getCompilerTarget() {
                    return compilerTarget;
                }

                /**
                 * Gets the value of the name property.
                 * 
                 * @return possible object is
                 *         {@link ProfileGLSL.Technique.Pass.Shader.Name }
                 */
                public ProfileGLSL.Technique.Pass.Shader.Name getName() {
                    return name;
                }

                /**
                 * Gets the value of the stage property.
                 * 
                 * @return possible object is {@link GlslPipelineStage }
                 */
                public GlslPipelineStage getStage() {
                    return stage;
                }

                /**
                 * Sets the value of the compilerOptions property.
                 * 
                 * @param value
                 *            allowed object is {@link String }
                 */
                public void setCompilerOptions(String value) {
                    compilerOptions = value;
                }

                /**
                 * Sets the value of the compilerTarget property.
                 * 
                 * @param value
                 *            allowed object is
                 *            {@link ProfileGLSL.Technique.Pass.Shader.CompilerTarget }
                 */
                public void setCompilerTarget(ProfileGLSL.Technique.Pass.Shader.CompilerTarget value) {
                    compilerTarget = value;
                }

                /**
                 * Sets the value of the name property.
                 * 
                 * @param value
                 *            allowed object is
                 *            {@link ProfileGLSL.Technique.Pass.Shader.Name }
                 */
                public void setName(ProfileGLSL.Technique.Pass.Shader.Name value) {
                    name = value;
                }

                /**
                 * Sets the value of the stage property.
                 * 
                 * @param value
                 *            allowed object is {@link GlslPipelineStage }
                 */
                public void setStage(GlslPipelineStage value) {
                    stage = value;
                }

            }

            @XmlElement(name = "annotate")
            protected List<FxAnnotateCommon> annotates;
            @XmlElement(name = "color_target")
            protected List<FxColortargetCommon> colorTargets;
            @XmlElement(name = "depth_target")
            protected List<FxDepthtargetCommon> depthTargets;
            @XmlElement(name = "stencil_target")
            protected List<FxStenciltargetCommon> stencilTargets;
            @XmlElement(name = "color_clear")
            protected List<FxClearcolorCommon> colorClears;
            @XmlElement(name = "depth_clear")
            protected List<FxCleardepthCommon> depthClears;
            @XmlElement(name = "stencil_clear")
            protected List<FxClearstencilCommon> stencilClears;
            protected String draw;
            @XmlElements({
                    @XmlElement(name = "sample_alpha_to_coverage_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.SampleAlphaToCoverageEnable.class),
                    @XmlElement(name = "light_specular", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.LightSpecular.class),
                    @XmlElement(name = "color_material_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.ColorMaterialEnable.class),
                    @XmlElement(name = "multisample_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.MultisampleEnable.class),
                    @XmlElement(name = "fog_mode", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.FogMode.class),
                    @XmlElement(name = "point_fade_threshold_size", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.PointFadeThresholdSize.class),
                    @XmlElement(name = "color_logic_op_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.ColorLogicOpEnable.class),
                    @XmlElement(name = "textureDEPTH", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.TextureDEPTH.class),
                    @XmlElement(name = "light_spot_direction", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.LightSpotDirection.class),
                    @XmlElement(name = "depth_mask", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.DepthMask.class),
                    @XmlElement(name = "clip_plane_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.ClipPlaneEnable.class),
                    @XmlElement(name = "scissor_test_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.ScissorTestEnable.class),
                    @XmlElement(name = "depth_test_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.DepthTestEnable.class),
                    @XmlElement(name = "depth_bounds_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.DepthBoundsEnable.class),
                    @XmlElement(name = "texture2D", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.Texture2D.class),
                    @XmlElement(name = "textureRECT_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.TextureRECTEnable.class),
                    @XmlElement(name = "stencil_test_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.StencilTestEnable.class),
                    @XmlElement(name = "material_ambient", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.MaterialAmbient.class),
                    @XmlElement(name = "alpha_test_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.AlphaTestEnable.class),
                    @XmlElement(name = "textureRECT", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.TextureRECT.class),
                    @XmlElement(name = "cull_face", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.CullFace.class),
                    @XmlElement(name = "light_model_ambient", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.LightModelAmbient.class),
                    @XmlElement(name = "light_quadratic_attenuation", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.LightQuadraticAttenuation.class),
                    @XmlElement(name = "shade_model", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.ShadeModel.class),
                    @XmlElement(name = "stencil_mask_separate", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.StencilMaskSeparate.class),
                    @XmlElement(name = "material_emission", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.MaterialEmission.class),
                    @XmlElement(name = "clear_depth", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.ClearDepth.class),
                    @XmlElement(name = "dither_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.DitherEnable.class),
                    @XmlElement(name = "textureDEPTH_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.TextureDEPTHEnable.class),
                    @XmlElement(name = "depth_range", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.DepthRange.class),
                    @XmlElement(name = "polygon_offset", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.PolygonOffset.class),
                    @XmlElement(name = "sample_coverage_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.SampleCoverageEnable.class),
                    @XmlElement(name = "light_constant_attenuation", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.LightConstantAttenuation.class),
                    @XmlElement(name = "material_shininess", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.MaterialShininess.class),
                    @XmlElement(name = "clear_color", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.ClearColor.class),
                    @XmlElement(name = "material_specular", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.MaterialSpecular.class),
                    @XmlElement(name = "depth_func", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.DepthFunc.class),
                    @XmlElement(name = "light_model_local_viewer_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.LightModelLocalViewerEnable.class),
                    @XmlElement(name = "light_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.LightEnable.class),
                    @XmlElement(name = "light_ambient", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.LightAmbient.class),
                    @XmlElement(name = "fog_color", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.FogColor.class),
                    @XmlElement(name = "light_spot_cutoff", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.LightSpotCutoff.class),
                    @XmlElement(name = "model_view_matrix", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.ModelViewMatrix.class),
                    @XmlElement(name = "blend_func_separate", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.BlendFuncSeparate.class),
                    @XmlElement(name = "stencil_op", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.StencilOp.class),
                    @XmlElement(name = "projection_matrix", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.ProjectionMatrix.class),
                    @XmlElement(name = "sample_alpha_to_one_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.SampleAlphaToOneEnable.class),
                    @XmlElement(name = "texture2D_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.Texture2DEnable.class),
                    @XmlElement(name = "textureCUBE_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.TextureCUBEEnable.class),
                    @XmlElement(name = "texture_env_color", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.TextureEnvColor.class),
                    @XmlElement(name = "lighting_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.LightingEnable.class),
                    @XmlElement(name = "logic_op_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.LogicOpEnable.class),
                    @XmlElement(name = "depth_bounds", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.DepthBounds.class),
                    @XmlElement(name = "fog_start", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.FogStart.class),
                    @XmlElement(name = "blend_color", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.BlendColor.class),
                    @XmlElement(name = "blend_equation_separate", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.BlendEquationSeparate.class),
                    @XmlElement(name = "polygon_stipple_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.PolygonStippleEnable.class),
                    @XmlElement(name = "blend_func", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.BlendFunc.class),
                    @XmlElement(name = "gl_hook_abstract"),
                    @XmlElement(name = "stencil_op_separate", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.StencilOpSeparate.class),
                    @XmlElement(name = "polygon_offset_fill_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.PolygonOffsetFillEnable.class),
                    @XmlElement(name = "point_size_max", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.PointSizeMax.class),
                    @XmlElement(name = "line_smooth_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.LineSmoothEnable.class),
                    @XmlElement(name = "depth_clamp_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.DepthClampEnable.class),
                    @XmlElement(name = "light_model_two_side_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.LightModelTwoSideEnable.class),
                    @XmlElement(name = "polygon_smooth_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.PolygonSmoothEnable.class),
                    @XmlElement(name = "light_linear_attenuation", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.LightLinearAttenuation.class),
                    @XmlElement(name = "clear_stencil", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.ClearStencil.class),
                    @XmlElement(name = "fog_end", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.FogEnd.class),
                    @XmlElement(name = "stencil_mask", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.StencilMask.class),
                    @XmlElement(name = "fog_density", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.FogDensity.class),
                    @XmlElement(name = "blend_equation", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.BlendEquation.class),
                    @XmlElement(name = "line_stipple", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.LineStipple.class),
                    @XmlElement(name = "line_stipple_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.LineStippleEnable.class),
                    @XmlElement(name = "light_diffuse", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.LightDiffuse.class),
                    @XmlElement(name = "fog_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.FogEnable.class),
                    @XmlElement(name = "cull_face_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.CullFaceEnable.class),
                    @XmlElement(name = "textureCUBE", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.TextureCUBE.class),
                    @XmlElement(name = "polygon_mode", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.PolygonMode.class),
                    @XmlElement(name = "alpha_func", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.AlphaFunc.class),
                    @XmlElement(name = "light_spot_exponent", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.LightSpotExponent.class),
                    @XmlElement(name = "rescale_normal_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.RescaleNormalEnable.class),
                    @XmlElement(name = "color_mask", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.ColorMask.class),
                    @XmlElement(name = "fog_coord_src", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.FogCoordSrc.class),
                    @XmlElement(name = "normalize_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.NormalizeEnable.class),
                    @XmlElement(name = "texture_env_mode", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.TextureEnvMode.class),
                    @XmlElement(name = "texture1D_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.Texture1DEnable.class),
                    @XmlElement(name = "light_model_color_control", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.LightModelColorControl.class),
                    @XmlElement(name = "blend_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.BlendEnable.class),
                    @XmlElement(name = "texture3D_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.Texture3DEnable.class),
                    @XmlElement(name = "scissor", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.Scissor.class),
                    @XmlElement(name = "line_width", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.LineWidth.class),
                    @XmlElement(name = "logic_op", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.LogicOp.class),
                    @XmlElement(name = "texture3D", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.Texture3D.class),
                    @XmlElement(name = "front_face", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.FrontFace.class),
                    @XmlElement(name = "polygon_offset_point_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.PolygonOffsetPointEnable.class),
                    @XmlElement(name = "polygon_offset_line_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.PolygonOffsetLineEnable.class),
                    @XmlElement(name = "color_material", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.ColorMaterial.class),
                    @XmlElement(name = "stencil_func", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.StencilFunc.class),
                    @XmlElement(name = "auto_normal_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.AutoNormalEnable.class),
                    @XmlElement(name = "point_size", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.PointSize.class),
                    @XmlElement(name = "texture1D", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.Texture1D.class),
                    @XmlElement(name = "clip_plane", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.ClipPlane.class),
                    @XmlElement(name = "point_smooth_enable", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.PointSmoothEnable.class),
                    @XmlElement(name = "point_size_min", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.PointSizeMin.class),
                    @XmlElement(name = "point_distance_attenuation", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.PointDistanceAttenuation.class),
                    @XmlElement(name = "shader", type = ProfileGLSL.Technique.Pass.Shader.class),
                    @XmlElement(name = "stencil_func_separate", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.StencilFuncSeparate.class),
                    @XmlElement(name = "material_diffuse", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.MaterialDiffuse.class),
                    @XmlElement(name = "light_position", type = de.bht.jvr.collada14.ProfileCG.Technique.Pass.LightPosition.class) })
            protected List<Object> alphaFuncsAndBlendFuncsAndBlendFuncSeparates;
            @XmlElement(name = "extra")
            protected List<Extra> extras;

            @XmlAttribute
            @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
            @XmlSchemaType(name = "NCName")
            protected String sid;

            /**
             * Gets the value of the
             * alphaFuncsAndBlendFuncsAndBlendFuncSeparates property.
             * <p>
             * This accessor method returns a reference to the live list, not a
             * snapshot. Therefore any modification you make to the returned
             * list will be present inside the JAXB object. This is why there is
             * not a <CODE>set</CODE> method for the
             * alphaFuncsAndBlendFuncsAndBlendFuncSeparates property.
             * <p>
             * For example, to add a new item, do as follows:
             * 
             * <pre>
             * getAlphaFuncsAndBlendFuncsAndBlendFuncSeparates().add(newItem);
             * </pre>
             * <p>
             * Objects of the following type(s) are allowed in the list
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.SampleAlphaToCoverageEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.LightSpecular }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.ColorMaterialEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.MultisampleEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.FogMode }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.PointFadeThresholdSize }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.ColorLogicOpEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.TextureDEPTH }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.LightSpotDirection }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.DepthMask }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.ClipPlaneEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.ScissorTestEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.DepthTestEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.DepthBoundsEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.Texture2D }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.TextureRECTEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.StencilTestEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.MaterialAmbient }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.AlphaTestEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.TextureRECT }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.CullFace }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.LightModelAmbient }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.LightQuadraticAttenuation }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.ShadeModel }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.StencilMaskSeparate }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.MaterialEmission }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.ClearDepth }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.DitherEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.TextureDEPTHEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.DepthRange }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.PolygonOffset }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.SampleCoverageEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.LightConstantAttenuation }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.MaterialShininess }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.ClearColor }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.MaterialSpecular }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.DepthFunc }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.LightModelLocalViewerEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.LightEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.LightAmbient }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.FogColor }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.LightSpotCutoff }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.ModelViewMatrix }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.BlendFuncSeparate }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.StencilOp }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.ProjectionMatrix }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.SampleAlphaToOneEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.Texture2DEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.TextureCUBEEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.TextureEnvColor }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.LightingEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.LogicOpEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.DepthBounds }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.FogStart }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.BlendColor }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.BlendEquationSeparate }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.PolygonStippleEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.BlendFunc }
             * {@link Object }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.StencilOpSeparate }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.PolygonOffsetFillEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.PointSizeMax }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.LineSmoothEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.DepthClampEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.LightModelTwoSideEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.PolygonSmoothEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.LightLinearAttenuation }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.ClearStencil }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.FogEnd }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.StencilMask }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.FogDensity }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.BlendEquation }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.LineStipple }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.LineStippleEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.LightDiffuse }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.FogEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.CullFaceEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.TextureCUBE }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.PolygonMode }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.AlphaFunc }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.LightSpotExponent }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.RescaleNormalEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.ColorMask }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.FogCoordSrc }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.NormalizeEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.TextureEnvMode }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.Texture1DEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.LightModelColorControl }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.BlendEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.Texture3DEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.Scissor }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.LineWidth }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.LogicOp }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.Texture3D }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.FrontFace }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.PolygonOffsetPointEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.PolygonOffsetLineEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.ColorMaterial }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.StencilFunc }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.AutoNormalEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.PointSize }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.Texture1D }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.ClipPlane }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.PointSmoothEnable }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.PointSizeMin }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.PointDistanceAttenuation }
             * {@link ProfileGLSL.Technique.Pass.Shader }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.StencilFuncSeparate }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.MaterialDiffuse }
             * {@link de.bht.jvr.collada14.ProfileCG.Technique.Pass.LightPosition }
             */
            public List<Object> getAlphaFuncsAndBlendFuncsAndBlendFuncSeparates() {
                if (alphaFuncsAndBlendFuncsAndBlendFuncSeparates == null)
                    alphaFuncsAndBlendFuncsAndBlendFuncSeparates = new ArrayList<Object>();
                return alphaFuncsAndBlendFuncsAndBlendFuncSeparates;
            }

            /**
             * Gets the value of the annotates property.
             * <p>
             * This accessor method returns a reference to the live list, not a
             * snapshot. Therefore any modification you make to the returned
             * list will be present inside the JAXB object. This is why there is
             * not a <CODE>set</CODE> method for the annotates property.
             * <p>
             * For example, to add a new item, do as follows:
             * 
             * <pre>
             * getAnnotates().add(newItem);
             * </pre>
             * <p>
             * Objects of the following type(s) are allowed in the list
             * {@link FxAnnotateCommon }
             */
            public List<FxAnnotateCommon> getAnnotates() {
                if (annotates == null)
                    annotates = new ArrayList<FxAnnotateCommon>();
                return annotates;
            }

            /**
             * Gets the value of the colorClears property.
             * <p>
             * This accessor method returns a reference to the live list, not a
             * snapshot. Therefore any modification you make to the returned
             * list will be present inside the JAXB object. This is why there is
             * not a <CODE>set</CODE> method for the colorClears property.
             * <p>
             * For example, to add a new item, do as follows:
             * 
             * <pre>
             * getColorClears().add(newItem);
             * </pre>
             * <p>
             * Objects of the following type(s) are allowed in the list
             * {@link FxClearcolorCommon }
             */
            public List<FxClearcolorCommon> getColorClears() {
                if (colorClears == null)
                    colorClears = new ArrayList<FxClearcolorCommon>();
                return colorClears;
            }

            /**
             * Gets the value of the colorTargets property.
             * <p>
             * This accessor method returns a reference to the live list, not a
             * snapshot. Therefore any modification you make to the returned
             * list will be present inside the JAXB object. This is why there is
             * not a <CODE>set</CODE> method for the colorTargets property.
             * <p>
             * For example, to add a new item, do as follows:
             * 
             * <pre>
             * getColorTargets().add(newItem);
             * </pre>
             * <p>
             * Objects of the following type(s) are allowed in the list
             * {@link FxColortargetCommon }
             */
            public List<FxColortargetCommon> getColorTargets() {
                if (colorTargets == null)
                    colorTargets = new ArrayList<FxColortargetCommon>();
                return colorTargets;
            }

            /**
             * Gets the value of the depthClears property.
             * <p>
             * This accessor method returns a reference to the live list, not a
             * snapshot. Therefore any modification you make to the returned
             * list will be present inside the JAXB object. This is why there is
             * not a <CODE>set</CODE> method for the depthClears property.
             * <p>
             * For example, to add a new item, do as follows:
             * 
             * <pre>
             * getDepthClears().add(newItem);
             * </pre>
             * <p>
             * Objects of the following type(s) are allowed in the list
             * {@link FxCleardepthCommon }
             */
            public List<FxCleardepthCommon> getDepthClears() {
                if (depthClears == null)
                    depthClears = new ArrayList<FxCleardepthCommon>();
                return depthClears;
            }

            /**
             * Gets the value of the depthTargets property.
             * <p>
             * This accessor method returns a reference to the live list, not a
             * snapshot. Therefore any modification you make to the returned
             * list will be present inside the JAXB object. This is why there is
             * not a <CODE>set</CODE> method for the depthTargets property.
             * <p>
             * For example, to add a new item, do as follows:
             * 
             * <pre>
             * getDepthTargets().add(newItem);
             * </pre>
             * <p>
             * Objects of the following type(s) are allowed in the list
             * {@link FxDepthtargetCommon }
             */
            public List<FxDepthtargetCommon> getDepthTargets() {
                if (depthTargets == null)
                    depthTargets = new ArrayList<FxDepthtargetCommon>();
                return depthTargets;
            }

            /**
             * Gets the value of the draw property.
             * 
             * @return possible object is {@link String }
             */
            public String getDraw() {
                return draw;
            }

            /**
             * Gets the value of the extras property.
             * <p>
             * This accessor method returns a reference to the live list, not a
             * snapshot. Therefore any modification you make to the returned
             * list will be present inside the JAXB object. This is why there is
             * not a <CODE>set</CODE> method for the extras property.
             * <p>
             * For example, to add a new item, do as follows:
             * 
             * <pre>
             * getExtras().add(newItem);
             * </pre>
             * <p>
             * Objects of the following type(s) are allowed in the list
             * {@link Extra }
             */
            public List<Extra> getExtras() {
                if (extras == null)
                    extras = new ArrayList<Extra>();
                return extras;
            }

            /**
             * Gets the value of the sid property.
             * 
             * @return possible object is {@link String }
             */
            public String getSid() {
                return sid;
            }

            /**
             * Gets the value of the stencilClears property.
             * <p>
             * This accessor method returns a reference to the live list, not a
             * snapshot. Therefore any modification you make to the returned
             * list will be present inside the JAXB object. This is why there is
             * not a <CODE>set</CODE> method for the stencilClears property.
             * <p>
             * For example, to add a new item, do as follows:
             * 
             * <pre>
             * getStencilClears().add(newItem);
             * </pre>
             * <p>
             * Objects of the following type(s) are allowed in the list
             * {@link FxClearstencilCommon }
             */
            public List<FxClearstencilCommon> getStencilClears() {
                if (stencilClears == null)
                    stencilClears = new ArrayList<FxClearstencilCommon>();
                return stencilClears;
            }

            /**
             * Gets the value of the stencilTargets property.
             * <p>
             * This accessor method returns a reference to the live list, not a
             * snapshot. Therefore any modification you make to the returned
             * list will be present inside the JAXB object. This is why there is
             * not a <CODE>set</CODE> method for the stencilTargets property.
             * <p>
             * For example, to add a new item, do as follows:
             * 
             * <pre>
             * getStencilTargets().add(newItem);
             * </pre>
             * <p>
             * Objects of the following type(s) are allowed in the list
             * {@link FxStenciltargetCommon }
             */
            public List<FxStenciltargetCommon> getStencilTargets() {
                if (stencilTargets == null)
                    stencilTargets = new ArrayList<FxStenciltargetCommon>();
                return stencilTargets;
            }

            /**
             * Sets the value of the draw property.
             * 
             * @param value
             *            allowed object is {@link String }
             */
            public void setDraw(String value) {
                draw = value;
            }

            /**
             * Sets the value of the sid property.
             * 
             * @param value
             *            allowed object is {@link String }
             */
            public void setSid(String value) {
                sid = value;
            }

        }

        @XmlElement(name = "annotate")
        protected List<FxAnnotateCommon> annotates;
        @XmlElements({ @XmlElement(name = "include", type = FxIncludeCommon.class),
                @XmlElement(name = "code", type = FxCodeProfile.class) })
        protected List<Object> codesAndIncludes;
        @XmlElements({ @XmlElement(name = "setparam", type = GlslSetparam.class),
                @XmlElement(name = "newparam", type = GlslNewparam.class),
                @XmlElement(name = "image", type = Image.class) })
        protected List<Object> imagesAndNewparamsAndSetparams;
        @XmlElement(name = "pass", required = true)
        protected List<ProfileGLSL.Technique.Pass> passes;
        @XmlElement(name = "extra")
        protected List<Extra> extras;
        @XmlAttribute
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected String id;

        @XmlAttribute(required = true)
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlSchemaType(name = "NCName")
        protected String sid;

        /**
         * Gets the value of the annotates property.
         * <p>
         * This accessor method returns a reference to the live list, not a
         * snapshot. Therefore any modification you make to the returned list
         * will be present inside the JAXB object. This is why there is not a
         * <CODE>set</CODE> method for the annotates property.
         * <p>
         * For example, to add a new item, do as follows:
         * 
         * <pre>
         * getAnnotates().add(newItem);
         * </pre>
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link FxAnnotateCommon }
         */
        public List<FxAnnotateCommon> getAnnotates() {
            if (annotates == null)
                annotates = new ArrayList<FxAnnotateCommon>();
            return annotates;
        }

        /**
         * Gets the value of the codesAndIncludes property.
         * <p>
         * This accessor method returns a reference to the live list, not a
         * snapshot. Therefore any modification you make to the returned list
         * will be present inside the JAXB object. This is why there is not a
         * <CODE>set</CODE> method for the codesAndIncludes property.
         * <p>
         * For example, to add a new item, do as follows:
         * 
         * <pre>
         * getCodesAndIncludes().add(newItem);
         * </pre>
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link FxIncludeCommon } {@link FxCodeProfile }
         */
        public List<Object> getCodesAndIncludes() {
            if (codesAndIncludes == null)
                codesAndIncludes = new ArrayList<Object>();
            return codesAndIncludes;
        }

        /**
         * Gets the value of the extras property.
         * <p>
         * This accessor method returns a reference to the live list, not a
         * snapshot. Therefore any modification you make to the returned list
         * will be present inside the JAXB object. This is why there is not a
         * <CODE>set</CODE> method for the extras property.
         * <p>
         * For example, to add a new item, do as follows:
         * 
         * <pre>
         * getExtras().add(newItem);
         * </pre>
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Extra }
         */
        public List<Extra> getExtras() {
            if (extras == null)
                extras = new ArrayList<Extra>();
            return extras;
        }

        /**
         * Gets the value of the id property.
         * 
         * @return possible object is {@link String }
         */
        public String getId() {
            return id;
        }

        /**
         * Gets the value of the imagesAndNewparamsAndSetparams property.
         * <p>
         * This accessor method returns a reference to the live list, not a
         * snapshot. Therefore any modification you make to the returned list
         * will be present inside the JAXB object. This is why there is not a
         * <CODE>set</CODE> method for the imagesAndNewparamsAndSetparams
         * property.
         * <p>
         * For example, to add a new item, do as follows:
         * 
         * <pre>
         * getImagesAndNewparamsAndSetparams().add(newItem);
         * </pre>
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link GlslSetparam } {@link GlslNewparam } {@link Image }
         */
        public List<Object> getImagesAndNewparamsAndSetparams() {
            if (imagesAndNewparamsAndSetparams == null)
                imagesAndNewparamsAndSetparams = new ArrayList<Object>();
            return imagesAndNewparamsAndSetparams;
        }

        /**
         * Gets the value of the passes property.
         * <p>
         * This accessor method returns a reference to the live list, not a
         * snapshot. Therefore any modification you make to the returned list
         * will be present inside the JAXB object. This is why there is not a
         * <CODE>set</CODE> method for the passes property.
         * <p>
         * For example, to add a new item, do as follows:
         * 
         * <pre>
         * getPasses().add(newItem);
         * </pre>
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link ProfileGLSL.Technique.Pass }
         */
        public List<ProfileGLSL.Technique.Pass> getPasses() {
            if (passes == null)
                passes = new ArrayList<ProfileGLSL.Technique.Pass>();
            return passes;
        }

        /**
         * Gets the value of the sid property.
         * 
         * @return possible object is {@link String }
         */
        public String getSid() {
            return sid;
        }

        /**
         * Sets the value of the id property.
         * 
         * @param value
         *            allowed object is {@link String }
         */
        public void setId(String value) {
            id = value;
        }

        /**
         * Sets the value of the sid property.
         * 
         * @param value
         *            allowed object is {@link String }
         */
        public void setSid(String value) {
            sid = value;
        }

    }

    protected Asset asset;
    @XmlElements({ @XmlElement(name = "include", type = FxIncludeCommon.class),
            @XmlElement(name = "code", type = FxCodeProfile.class) })
    protected List<Object> codesAndIncludes;
    @XmlElements({ @XmlElement(name = "newparam", type = GlslNewparam.class),
            @XmlElement(name = "image", type = Image.class) })
    protected List<Object> imagesAndNewparams;
    @XmlElement(name = "technique", required = true)
    protected List<ProfileGLSL.Technique> techniques;
    @XmlElement(name = "extra")
    protected List<Extra> extras;

    @XmlAttribute
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlID
    @XmlSchemaType(name = "ID")
    protected String id;

    /**
     * Gets the value of the asset property.
     * 
     * @return possible object is {@link Asset }
     */
    public Asset getAsset() {
        return asset;
    }

    /**
     * Gets the value of the codesAndIncludes property.
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the codesAndIncludes property.
     * <p>
     * For example, to add a new item, do as follows:
     * 
     * <pre>
     * getCodesAndIncludes().add(newItem);
     * </pre>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link FxIncludeCommon } {@link FxCodeProfile }
     */
    public List<Object> getCodesAndIncludes() {
        if (codesAndIncludes == null)
            codesAndIncludes = new ArrayList<Object>();
        return codesAndIncludes;
    }

    /**
     * Gets the value of the extras property.
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the extras property.
     * <p>
     * For example, to add a new item, do as follows:
     * 
     * <pre>
     * getExtras().add(newItem);
     * </pre>
     * <p>
     * Objects of the following type(s) are allowed in the list {@link Extra }
     */
    public List<Extra> getExtras() {
        if (extras == null)
            extras = new ArrayList<Extra>();
        return extras;
    }

    /**
     * Gets the value of the id property.
     * 
     * @return possible object is {@link String }
     */
    public String getId() {
        return id;
    }

    /**
     * Gets the value of the imagesAndNewparams property.
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the imagesAndNewparams property.
     * <p>
     * For example, to add a new item, do as follows:
     * 
     * <pre>
     * getImagesAndNewparams().add(newItem);
     * </pre>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link GlslNewparam } {@link Image }
     */
    public List<Object> getImagesAndNewparams() {
        if (imagesAndNewparams == null)
            imagesAndNewparams = new ArrayList<Object>();
        return imagesAndNewparams;
    }

    /**
     * Gets the value of the techniques property.
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the techniques property.
     * <p>
     * For example, to add a new item, do as follows:
     * 
     * <pre>
     * getTechniques().add(newItem);
     * </pre>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ProfileGLSL.Technique }
     */
    public List<ProfileGLSL.Technique> getTechniques() {
        if (techniques == null)
            techniques = new ArrayList<ProfileGLSL.Technique>();
        return techniques;
    }

    /**
     * Sets the value of the asset property.
     * 
     * @param value
     *            allowed object is {@link Asset }
     */
    public void setAsset(Asset value) {
        asset = value;
    }

    /**
     * Sets the value of the id property.
     * 
     * @param value
     *            allowed object is {@link String }
     */
    public void setId(String value) {
        id = value;
    }

}
